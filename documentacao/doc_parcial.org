#+title: A linguagem de programação Simple3
#+options: date:nil author:nil toc:nil
#+latex_header: \usepackage{indentfirst}
#+latex_header: \usepackage[margin=2cm]{geometry}
#+latex_header: \usepackage[utf8]{inputenc}
#+latex_header: \usepackage[brazilian]{babel}
#+latex_header: \author{{Bellini, Leon F.}\\{\small 22218002-8} \and {Sampaio, Guilherme O.}\\{\small 22218007-7} \and {Barbosa, Pedro F. M.}\\{\small 22218013-5} \and {de Sousa, Felipe M.}\\{\small 22218042-4}}

* Introdução
Fanáticos por minimalismo e simplicidade cravam por uma linguagem
desenvolvida como a *Simple3*, na qual o limite de três caracteres em
todas as palavras-chave permite a criação de arquivos fonte com
menores dimensões em questões de espaço em disco utilizado. Vide a
seção [[* Utilização do compilador]] para as instruções de como programar
e compilar um arquivo fonte da *Simple3*.

* Tokens e suas expressões regulares
A seguir encontram-se relações de todos *tokens* presentes na linguagem,
bem como as expressões regulares relacionadas à captura destes. Para
maior informação quanto à utilização e significado de cada *token*,
basta ler o conteúdo presente no arquivo =tokens.py= como mostrado no
exemplo abaixo:

#+begin_src sh
less tokens.py 
#+end_src

** Palavras-chave
| *Keywords*  | Expressão regular | Observação                   |
|-----------+-------------------+------------------------------|
| =tof=       | "tof"             |                              |
| =ifi=       | "ifi"             |                              |
| =els=       | "els"             |                              |
| =elf=       | "elf"             |                              |
| =whl=       | "whl"             |                              |
| =for=       | "for"             |                              |
| =str=       | "str"             |                              |
| =num=       | "num"             |                              |
| =brk=       | "brk"             |                              |
| =jmp=       | "jmp"             |                              |
| =ret=       | "ret"             |                              |
| {...}     | "\ {" e "\ }"     | definição de escopo          |
| \([...]\) | "\ [" e "\ ]"     | acesso ou definição de vetor |
| (...)     | "\ (" e "\ )"     |                              |
| =emp=       | "emp"             | *nil* ou *null*                  |
| =tru=       | "tru"             |                              |
| =fls=       | "fls"             |                              |
| =eos=       | ";"               | fim de comando/diretiva      |
|-----------+-------------------+------------------------------|

** Literais

| Identificadores | Expressão regular   | Observação  |
|-----------------+---------------------+-------------|
| =num=             | "[0-9]+(\.[0-9]+)?" |             |
| =str=             | "\"[\wedge\"]*\""        |             |
| =comment=         | "\wedge(\/3).*\dollar"         | linha única |
|-----------------+---------------------+-------------|

** Identificadores
| Identificadores | Expressão regular | Observação         |
|-----------------+-------------------+--------------------|
| =var=             | "[A-z]{3}"        | apenas três letras |
|-----------------+-------------------+--------------------|

** Operadores

| Operador   | Expressão regular | Observação            |
|------------+-------------------+-----------------------|
| \(+\)      | "\+"              |                       |
| \(-\)      | "\-"              |                       |
| \(*\)      | "\*"              |                       |
| \(/\)      | "\/"              |                       |
| \(\hat{}\) | "\wedge"               | exponenciação         |
| \(>\)      | "\>"              |                       |
| \(<\)      | "\<"              |                       |
| \(>=\)     | "\>\="            |                       |
| \(<=\)     | "\<\="            |                       |
| \(=\)      | "\="              |                       |
| \(==\)     | "\=\="            |                       |
| \(!\)      | "\!"              |                       |
| =orr=        | "orr"             |                       |
| =and=        | "and"             |                       |
| \(:\)      | ":"               | operador de intervalo |
|------------+-------------------+-----------------------|


* Utilização do compilador
Basta invocar o arquivo principal =comple.py= localizado na pasta raiz do
projeto juntamente com a versão mais recente de *Python 3*. No caso, esta seria,
também, a única dependência explicita do projeto. A sintaxe de uma compilação
comum dá se por:

#+begin_src sh
  python comple.py alvo.sp3
#+end_src

Note que a extensão do arquivo deve conter, necessariamente, o sufixo
=.sp3=. Qualquer outro arquivo será negado pelo compilador. O executável
de saída após a compilação tem o nome fixo =output.py= (no momento
=output.txt=). Além disso, devido à dificuldades relacionadas à variável de *PATH*, é
recomendado que o /script/ seja executado na pasta raiz do projeto. 

** Particularidades do analisador léxico
   Trata-se de um componente que executa uma única passagem. Caso seja
desejado trabalhar com sua classe, =simple_lexer=, o método =get_token= é
disponibilizado para aqueles que tenham interesse em saber qual /token/
foi reconhecido em determinada linha *x*. Devido à natureza de analisadores
léxicos de passagem única, não foi implementado um método =get_next_token=.

#+latex: \clearpage
** Exemplo de arquivo fonte
Um arquivo fonte da *Simple3* tem estrutura semelhante ao exemplo a
seguir:
#+include: ./arquivo_teste.sp3 example

** Output
   No momento, apenas a fase de *análise léxica* apresenta-se como
completa.  Por esse motivo, o arquivo =output.txt= o qual aparece na
pasta raiz tem como função de mostrar todos os tokens reconhecidos
durante a última execução. Este mostrará uma relação de todos os
/tokens/ encontrados em uma linha além de, ao fim, imprimir a tabela de
símbolos.

A saída tem como formato:

#+begin_example
Linha x: (<tipo>, <valor>, escopo)

Tabela de simbolos
<valores da tabela>
...
#+end_example

Na qual =escopo= tem valor de 0 (global) a 1 (local). Note que uma variável
nomeada pode aparecer em mais de um local, a priorização, entretanto, será
tratada em fases posteriores.
